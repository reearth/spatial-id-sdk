{"version":3,"file":"index.js","sources":["../src/zfxy.ts","../src/zfxy_tilehash.ts","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/@turf/bbox/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../node_modules/@turf/line-segment/dist/es/index.js","../node_modules/quickselect/index.js","../node_modules/rbush/index.js","../node_modules/@turf/helpers/dist/js/index.js","../node_modules/@turf/meta/dist/js/index.js","../node_modules/@turf/bbox/dist/js/index.js","../node_modules/geojson-rbush/index.js","../node_modules/@turf/line-intersect/dist/es/index.js","../node_modules/@turf/polygon-to-line/dist/es/index.js","../node_modules/@turf/boolean-disjoint/dist/es/index.js","../node_modules/@turf/boolean-intersects/dist/es/index.js","../src/tilebelt.ts","../src/hilbert.ts","../src/hilbert_tilehash.ts","../src/index.ts"],"sourcesContent":["import { LngLat, LngLatWithAltitude } from \"./types\";\n\nexport type ZFXYTile = { z: number, f: number, x: number, y: number };\n\nexport function isZFXYTile(tile: any): tile is ZFXYTile {\n  return ('z' in tile && 'f' in tile && 'x' in tile && 'y' in tile);\n}\n\nexport const ZFXY_1M_ZOOM_BASE = 25 as const;\nexport const ZFXY_ROOT_TILE: ZFXYTile = { f: 0, x: 0, y: 0, z: 0 };\n\nconst rad2deg = 180 / Math.PI;\n\nexport function getParent(tile: ZFXYTile, steps: number = 1): ZFXYTile {\n  const { f,x,y,z } = tile;\n  if (steps <= 0) {\n    throw new Error('steps must be greater than 0');\n  }\n  if (steps > z) {\n    throw new Error(`Getting parent tile of ${tile}, ${steps} steps is not possible because it would go beyond the root tile (z=0)`);\n  }\n  return {\n    f: f >> steps,\n    x: x >> steps,\n    y: y >> steps,\n    z: z -  steps,\n  };\n}\n\nexport function getChildren(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\n  const {f,x,y,z} = tile;\n  return [\n    {f: f * 2,     x: x * 2,     y: y * 2,     z: z+1}, // f +0, x +0, y +0\n    {f: f * 2,     x: x * 2 + 1, y: y * 2,     z: z+1}, // f +0, x +1, y +0\n    {f: f * 2,     x: x * 2,     y: y * 2 + 1, z: z+1}, // f +0, x +0, y +1\n    {f: f * 2,     x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +0, x +1, y +1\n    {f: f * 2 + 1, x: x * 2,     y: y * 2,     z: z+1}, // f +1, x +0, y +0\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2,     z: z+1}, // f +1, x +1, y +0\n    {f: f * 2 + 1, x: x * 2,     y: y * 2 + 1, z: z+1}, // f +1, x +0, y +1\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +1, x +1, y +1\n  ];\n}\n\nexport function getSurrounding(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\n  const {f,x,y,z} = tile;\n  return [\n    zfxyWraparound({f: f, x: x,     y: y,     z: z}), // f +0, x +0, y +0\n    zfxyWraparound({f: f, x: x + 1, y: y,     z: z}), // f +0, x +1, y +0\n    zfxyWraparound({f: f, x: x,     y: y + 1, z: z}), // f +0, x +0, y +1\n    zfxyWraparound({f: f, x: x + 1, y: y + 1, z: z}), // f +0, x +1, y +1\n    zfxyWraparound({f: f, x: x - 1, y: y,     z: z}), // f +0, x -1, y +0\n    zfxyWraparound({f: f, x: x,     y: y - 1, z: z}), // f +0, x +0, y -1\n    zfxyWraparound({f: f, x: x - 1, y: y - 1, z: z}), // f +0, x -1, y -1\n    zfxyWraparound({f: f, x: x + 1, y: y - 1, z: z}), // f +0, x +1, y -1\n    zfxyWraparound({f: f, x: x - 1, y: y + 1, z: z}), // f +0, x -1, y +1\n  ];\n}\n\nexport function parseZFXYString(str: string): ZFXYTile | undefined {\n  const match = str.match(/^\\/?(\\d+)\\/(?:(\\d+)\\/)?(\\d+)\\/(\\d+)$/);\n  if (!match) {\n    return undefined;\n  }\n  return {\n    z: parseInt(match[1], 10),\n    f: parseInt(match[2] || '0', 10),\n    x: parseInt(match[3], 10),\n    y: parseInt(match[4], 10),\n  };\n}\n\n/** Returns the lng,lat of the northwest corner of the provided tile */\nexport function getLngLat(tile: ZFXYTile): LngLat {\n  const n = Math.PI - 2 * Math.PI * tile.y / Math.pow(2, tile.z);\n  return {\n    lng: tile.x / Math.pow(2, tile.z) * 360 - 180,\n    lat: rad2deg * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))),\n  };\n}\n\nexport function getCenterLngLat(tile: ZFXYTile): LngLat {\n  const x = tile.x * 2 + 1,\n        y = tile.y * 2 + 1,\n        z = tile.z + 1;\n  return getLngLat({x, y, z, f: 0});\n}\n\nexport function getCenterLngLatAlt(tile: ZFXYTile): LngLatWithAltitude {\n  return {\n    ...getCenterLngLat(tile),\n    alt: getFloor(tile) + ((2**ZFXY_1M_ZOOM_BASE) / (2**(tile.z + 1))),\n  };\n}\n\nexport function getBBox(tile: ZFXYTile): [LngLat, LngLat] {\n  const nw = getLngLat(tile),\n        se = getLngLat({...tile, y: tile.y + 1, x: tile.x + 1});\n  return [ nw, se ];\n}\n\n/** Returns the floor of the voxel, in meters */\nexport function getFloor(tile: ZFXYTile): number {\n  return tile.f * (2**ZFXY_1M_ZOOM_BASE) / (2**tile.z)\n}\n\nexport interface CalculateZFXYInput {\n  lat: number\n  lng: number\n  alt?: number\n  zoom: number\n}\n\nexport function calculateZFXY(input: CalculateZFXYInput): ZFXYTile {\n  const meters = typeof input.alt !== 'undefined' ? input.alt : 0;\n  if (meters <= -(2**ZFXY_1M_ZOOM_BASE) || meters >= (2**ZFXY_1M_ZOOM_BASE)) {\n    // TODO: make altitude unlimited?\n    throw new Error(`ZFXY only supports altitude between -2^${ZFXY_1M_ZOOM_BASE} and +2^${ZFXY_1M_ZOOM_BASE}.`);\n  }\n  const f = Math.floor(((2 ** input.zoom) * meters) / (2 ** ZFXY_1M_ZOOM_BASE));\n\n  // Algorithm adapted from tilebelt.js\n  const d2r = Math.PI / 180;\n  const sin = Math.sin(input.lat * d2r);\n  const z2 = 2 ** input.zoom;\n  let x = z2 * (input.lng / 360 + 0.5);\n  const y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n  // Wrap Tile X\n  x = x % z2;\n  if (x < 0) x = x + z2;\n\n  return {\n    f: f,\n    x: Math.floor(x),\n    y: Math.floor(y),\n    z: input.zoom,\n  };\n}\n\n/**\n * Fix a tile that has out-of-bounds coordinates by:\n * for the x and y coordinates: wrapping the coordinates around.\n * for the f coordinate: limiting to maximum or minimum.\n */\nexport function zfxyWraparound(tile: ZFXYTile): ZFXYTile {\n  const {z, f, x, y} = tile;\n  return {\n    z,\n    f: Math.max(Math.min(f, (2**z)), -(2**z)),\n    x: (x < 0) ? x + 2**z : x % 2**z,\n    y: (y < 0) ? y + 2**z : y % 2**z,\n  }\n}\n","import { ZFXYTile, getChildren, getParent } from \"./zfxy\";\n\nexport function parseZFXYTilehash(th: string): ZFXYTile {\n  let negativeF = false;\n  if (th[0] === '-') {\n    negativeF = true;\n    th = th.substring(1);\n  }\n  let children = getChildren();\n  let lastChild: ZFXYTile;\n  for (const c of th) {\n    lastChild = {...children[parseInt(c, 10) - 1]};\n    children = getChildren(lastChild);\n  }\n  if (negativeF) {\n    lastChild.f = -lastChild.f;\n  }\n  return lastChild;\n}\n\nexport function generateTilehash(tile: ZFXYTile): string {\n  let {f,x,y,z} = tile;\n  const originalF = f;\n  let out = '';\n  while (z>0) {\n    const thisTile: ZFXYTile = { f: Math.abs(f), x: x, y: y, z: z };\n    const parent = getParent(thisTile);\n    const childrenOfParent = getChildren(parent);\n    const positionInParent = childrenOfParent.findIndex(\n      (child) => child.f === Math.abs(f) && child.x === x && child.y === y && child.z === z\n    );\n    out = (positionInParent + 1).toString() + out;\n    f = parent.f;\n    x = parent.x;\n    y = parent.y;\n    z = parent.z;\n  }\n  return (originalF < 0 ? '-' : '') + out;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = helpers.lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              helpers.lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return helpers.point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexports.coordAll = coordAll;\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.findPoint = findPoint;\nexports.findSegment = findSegment;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexports.default = bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","import booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Boolean-intersects returns (TRUE) two geometries intersect.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point);\n * //=true\n */\nexport default function booleanIntersects(feature1, feature2) {\n    var bool = false;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === true) {\n                return true;\n            }\n            bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n","import { BBox } from \"geojson\";\n\nconst d2r = Math.PI / 180,\n      r2d = 180 / Math.PI,\n      MAX_ZOOM = 28;\n\nexport function getBboxZoom(bbox: BBox) {\n  for (let z = 0; z < MAX_ZOOM; z++) {\n    const mask = 1 << (32 - (z + 1));\n    if (((bbox[0] & mask) !== (bbox[2] & mask)) ||\n        ((bbox[1] & mask) !== (bbox[3] & mask))) {\n      return z;\n    }\n  }\n\n  return MAX_ZOOM;\n}\n\n/**\n * Get the smallest tile to cover a bbox\n */\nexport function bboxToTile(bboxCoords: BBox, minZoom?: number): Array<number> {\n  const min = pointToTile(bboxCoords[0], bboxCoords[1], 32);\n  const max = pointToTile(bboxCoords[2], bboxCoords[3], 32);\n  const bbox: BBox = [min[0], min[1], max[0], max[1]];\n\n  const z = Math.min(getBboxZoom(bbox), typeof minZoom !== 'undefined' ? minZoom : MAX_ZOOM);\n  if (z === 0) return [0, 0, 0];\n  const x = bbox[0] >>> (32 - z);\n  const y = bbox[1] >>> (32 - z);\n  return [x, y, z];\n}\n\n/**\n * Get the tile for a point at a specified zoom level\n */\nexport function pointToTile(lon: number, lat: number, z: number) {\n  var tile = pointToTileFraction(lon, lat, z);\n  tile[0] = Math.floor(tile[0]);\n  tile[1] = Math.floor(tile[1]);\n  return tile;\n}\n\n/**\n * Get the precise fractional tile location for a point at a zoom level\n */\nfunction pointToTileFraction(lon: number, lat: number, z: number) {\n  var sin = Math.sin(lat * d2r),\n      z2 = Math.pow(2, z),\n      x = z2 * (lon / 360 + 0.5),\n      y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n  // Wrap Tile X\n  x = x % z2;\n  if (x < 0) x = x + z2;\n  return [x, y, z];\n}\n","// Function 1: Encode (x,y,z) to Hilbert curve index\nexport function encodeHilbert3D(x: number, y: number, z: number, bits: number): bigint {\n  let morton = encodeMorton3D(x, y, z);\n  return mortonToHilbertN(morton, bits);\n}\n\n// Function 2: Decode Hilbert curve index to (x,y,z)\nexport function decodeHilbert3D(index: bigint, bits: number): [number, number, number] {\n  const morton = hilbertToMortonN(index, bits);\n  return decodeMorton3D(morton);\n}\n\n// Helper functions: Encode/decode Morton curve using magic bits\n// This is a 3D Morton curve implementation, adapted from https://stackoverflow.com/questions/1024754/how-to-compute-a-3d-morton-number-interleave-the-bits-of-3-ints\nexport function encodeMorton3D(x: number, y: number, z: number): bigint {\n  let morton = 0n;\n  morton = splitBy3(x) | (splitBy3(y) << 1n) | (splitBy3(z) << 2n);\n  return morton;\n}\n\nexport function decodeMorton3D(morton: bigint): [number, number, number] {\n  let x = compactBy3(morton);\n  let y = compactBy3(morton >> 1n);\n  let z = compactBy3(morton >> 2n);\n  return [x, y, z];\n}\n\nfunction splitBy3(a: number): bigint {\n  let x = BigInt(a) & BigInt('0x3ffffffffff');\n  x = (x | x << 64n) & BigInt('0x3ff0000000000000000ffffffff');\n  x = (x | x << 32n) & BigInt('0x3ff00000000ffff00000000ffff');\n  x = (x | x << 16n) & BigInt('0x30000ff0000ff0000ff0000ff0000ff');\n  x = (x | x <<  8n) & BigInt('0x300f00f00f00f00f00f00f00f00f00f');\n  x = (x | x <<  4n) & BigInt('0x30c30c30c30c30c30c30c30c30c30c3');\n  x = (x | x <<  2n) & BigInt('0x9249249249249249249249249249249');\n  return x;\n}\n\nfunction compactBy3(a: bigint): number {\n  let x = a & BigInt('0x9249249249249249249249249249249');\n  x = (x | x >>  2n) & BigInt('0x30c30c30c30c30c30c30c30c30c30c3');\n  x = (x | x >>  4n) & BigInt('0x300f00f00f00f00f00f00f00f00f00f');\n  x = (x | x >>  8n) & BigInt('0x30000ff0000ff0000ff0000ff0000ff');\n  x = (x | x >> 16n) & BigInt('0x3ff00000000ffff00000000ffff');\n  x = (x | x >> 32n) & BigInt('0x3ff0000000000000000ffffffff');\n  x = (x | x >> 64n) & BigInt('0x3ffffffffff');\n  return Number(x);\n}\n\n// Helper functions: Translate morton/hilbert codes using a simple lookup table\n// This code has been adapted from http://threadlocalmutex.com/?p=149\nconst mortonToHilbertTable: number[] = [\n  48, 33, 27, 34, 47, 78, 28, 77,\n  66, 29, 51, 52, 65, 30, 72, 63,\n  76, 95, 75, 24, 53, 54, 82, 81,\n  18,  3, 17, 80, 61,  4, 62, 15,\n   0, 59, 71, 60, 49, 50, 86, 85,\n  84, 83,  5, 90, 79, 56,  6, 89,\n  32, 23,  1, 94, 11, 12,  2, 93,\n  42, 41, 13, 14, 35, 88, 36, 31,\n  92, 37, 87, 38, 91, 74,  8, 73,\n  46, 45,  9, 10,  7, 20, 64, 19,\n  70, 25, 39, 16, 69, 26, 44, 43,\n  22, 55, 21, 68, 57, 40, 58, 67,\n];\n\nconst hilbertToMortonTable: number[] = [\n  48, 33, 35, 26, 30, 79, 77, 44,\n  78, 68, 64, 50, 51, 25, 29, 63,\n  27, 87, 86, 74, 72, 52, 53, 89,\n  83, 18, 16,  1,  5, 60, 62, 15,\n   0, 52, 53, 57, 59, 87, 86, 66,\n  61, 95, 91, 81, 80,  2,  6, 76,\n  32,  2,  6, 12, 13, 95, 91, 17,\n  93, 41, 40, 36, 38, 10, 11, 31,\n  14, 79, 77, 92, 88, 33, 35, 82,\n  70, 10, 11, 23, 21, 41, 40,  4,\n  19, 25, 29, 47, 46, 68, 64, 34,\n  45, 60, 62, 71, 67, 18, 16, 49,\n];\n\nfunction transformCurve(inValue: bigint, bits: number, lookupTable: number[]): bigint {\n  let transform = 0;\n  let out = 0n;\n\n  for (let i = 3 * (bits - 1); i >= 0; i -= 3) {\n    transform = lookupTable[transform | Number((inValue >> BigInt(i)) & 7n)];\n    out = (out << 3n) | BigInt(transform & 7);\n    transform &= ~7;\n  }\n\n  return out;\n};\n\nfunction mortonToHilbertN(mortonIndex: bigint, bits: number): bigint {\n  return transformCurve(mortonIndex, bits, mortonToHilbertTable);\n}\nfunction hilbertToMortonN(hilbertIndex: bigint, bits: number): bigint {\n  return transformCurve(hilbertIndex, bits, hilbertToMortonTable);\n}\n","// Functions to encode/decode 3D xyz coordinates to/from a Hilbert distance\n// Uses Skilling's algorithm because it was the easiest to adapt to 3D coordinates\n// (it's actually able to handle any number of dimensions, but we only need 3 right now)\n\nimport { ZFXYTile } from \"./zfxy\";\nimport { encodeHilbert3D, decodeHilbert3D } from \"./hilbert\";\n\nexport function generateHilbertIndex(tile: ZFXYTile): bigint {\n  // normalize the f attribute to be positive\n  // this allows negative f values to be encoded in the hilbert index\n  const f = tile.z > 0 ? tile.f + (2 ** (tile.z - 1)) : 0;\n  return encodeHilbert3D(tile.x, tile.y, f, tile.z);\n}\n\nexport function parseHilbertIndex(hilbertDistance: bigint, z: number): ZFXYTile {\n  if (z === 0) { return { z: 0, f: 0, x: 0, y: 0 }; }\n\n  const [x, y, originalF] = decodeHilbert3D(hilbertDistance, z);\n  // denormalize the f attribute\n  const f = originalF - (2 ** (z - 1));\n  return { f, x, y, z };\n}\n\nexport function generateHilbertTilehash(hilbertIndex: bigint, order: number): string {\n  // radix 8 compresses 3 bits into 1 character (0-7)\n  // we want 1-8, so we add 1 to each digit of the string\n  return 'H' + hilbertIndex.toString(8).padStart(order, '0').split('').map((c) => (parseInt(c) + 1).toString()).join('');\n}\n\nexport function parseHilbertTilehash(th: string): undefined | ZFXYTile {\n  if (th[0] !== 'H') {\n    return undefined;\n  }\n  // need to subtract 1 from each digit to convert back to radix 8\n  const thDigits = th.substring(1).split('').map((c) => (parseInt(c) - 1).toString()).join('');\n  const hilbertDistance = BigInt(\"0o\" + thDigits); // thDigits is in radix 8, so we can parse it as an octal\n  return parseHilbertIndex(hilbertDistance, thDigits.length);\n}\n","import { LngLatWithAltitude } from \"./types\";\nimport { calculateZFXY, getBBox, getChildren, getFloor, getParent, isZFXYTile, parseZFXYString, ZFXYTile, zfxyWraparound, getSurrounding, getCenterLngLatAlt } from \"./zfxy\";\nimport { generateTilehash, parseZFXYTilehash } from \"./zfxy_tilehash\";\nimport turfBBox from '@turf/bbox';\nimport turfBooleanIntersects from '@turf/boolean-intersects';\nimport type { Geometry, Polygon } from \"geojson\";\nimport { bboxToTile, pointToTile } from \"./tilebelt\";\nimport { generateHilbertIndex, generateHilbertTilehash, parseHilbertTilehash } from \"./hilbert_tilehash\";\n\nconst DEFAULT_ZOOM = 25 as const;\n\nexport class Space {\n  center: LngLatWithAltitude\n  alt: number\n  zoom: number\n\n  zfxy: ZFXYTile\n\n  id: string\n  zfxyStr: string\n  tilehash: string\n  hilbertIndex: bigint\n  hilbertTilehash: string\n\n  /**\n   * Create a new Space\n   *\n   * @param input A LngLatWithAltitude or string containing either a ZFXY or tilehash-encoded ZFXY.\n   * @param zoom Optional. Defaults to 25 when `input` is LngLatWithAltitude. Ignored when ZXFY or tilehash is provided.\n   */\n  constructor(input: LngLatWithAltitude | ZFXYTile | string, zoom?: number) {\n    if (typeof input === 'string') {\n      // parse string\n      let zfxy = parseZFXYString(input) || parseHilbertTilehash(input) || parseZFXYTilehash(input);\n      if (zfxy) {\n        this.zfxy = zfxy;\n        this._regenerateAttributesFromZFXY();\n      } else {\n        throw new Error(`parse ZFXY failed with input: ${input}`);\n      }\n      return;\n    } else if (isZFXYTile(input)) {\n      this.zfxy = input;\n      this._regenerateAttributesFromZFXY();\n      return;\n    } else {\n      this.zfxy = calculateZFXY({\n        ...input,\n        zoom: (typeof zoom !== 'undefined') ? zoom : DEFAULT_ZOOM,\n      });\n    }\n\n    this._regenerateAttributesFromZFXY();\n  }\n\n  /* - PUBLIC API - */\n\n  up(by: number = 1) {\n    return this.move({f: by});\n  }\n\n  down(by: number = 1) {\n    return this.move({f: -by});\n  }\n\n  north(by: number = 1) {\n    return this.move({y: by});\n  }\n\n  south(by: number = 1) {\n    return this.move({y: -by});\n  }\n\n  east(by: number = 1) {\n    return this.move({x: by});\n  }\n\n  west(by: number = 1) {\n    return this.move({x: -by});\n  }\n\n  move(by: Partial<Omit<ZFXYTile, 'z'>>) {\n    const newSpace = new Space(this.zfxy);\n    newSpace.zfxy = zfxyWraparound({\n      z: newSpace.zfxy.z,\n      f: newSpace.zfxy.f + (by.f || 0),\n      x: newSpace.zfxy.x + (by.x || 0),\n      y: newSpace.zfxy.y + (by.y || 0),\n    });\n    newSpace._regenerateAttributesFromZFXY();\n    return newSpace;\n  }\n\n  parent(atZoom?: number) {\n    const steps = (typeof atZoom === 'undefined') ? 1 : this.zfxy.z - atZoom;\n    return new Space(getParent(this.zfxy, steps));\n  }\n\n  children() {\n    return getChildren(this.zfxy).map((tile) => new Space(tile));\n  }\n\n  /** Return an array of Space objects at the same zoom level that surround this Space\n   * object. This method does not return the Space object itself, so the array will\n   * contain 26 Space objects.\n   */\n  surroundings(): Space[] {\n    return [\n      ...(\n        getSurrounding(this.zfxy)\n        .filter(({z,f,x,y}) => `/${z}/${f}/${x}/${y}` !== this.zfxyStr)\n        .map((tile) => new Space(tile))\n      ),\n      ...(\n        getSurrounding(this.up().zfxy)\n        .map((tile) => new Space(tile))\n      ),\n      ...(\n        getSurrounding(this.down().zfxy)\n        .map((tile) => new Space(tile))\n      ),\n    ];\n  }\n\n  /** Returns true if a point lies within this Space. If the position's altitude is not\n   * specified, it is ignored from the calculation.\n   */\n  contains(position: LngLatWithAltitude) {\n    const geom = this.toGeoJSON();\n    const point = {\n      type: 'Point',\n      coordinates: [position.lng, position.lat],\n    };\n    const floor = this.alt;\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\n    return (\n      turfBooleanIntersects(geom, point) &&\n      (typeof position.alt !== 'undefined' === true ?\n        position.alt >= floor && position.alt < ceil\n        :\n        true\n      )\n    );\n  }\n\n  /** Calculates the polygon of this Space and returns a 2D GeoJSON Polygon. */\n  toGeoJSON(): Polygon {\n    const [nw, se] = getBBox(this.zfxy);\n    return {\n      type: 'Polygon',\n      coordinates: [\n        [\n          [nw.lng, nw.lat],\n          [nw.lng, se.lat],\n          [se.lng, se.lat],\n          [se.lng, nw.lat],\n          [nw.lng, nw.lat],\n        ],\n      ],\n    };\n  }\n\n  /** Calculates the 3D polygon of this Space and returns the vertices of that polygon. */\n  vertices3d(): [number, number, number][] {\n    const [nw, se] = getBBox(this.zfxy);\n    const floor = getFloor(this.zfxy);\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\n    return [\n      [nw.lng, nw.lat, floor],\n      [nw.lng, se.lat, floor],\n      [se.lng, se.lat, floor],\n      [se.lng, nw.lat, floor],\n      [nw.lng, nw.lat, ceil],\n      [nw.lng, se.lat, ceil],\n      [se.lng, se.lat, ceil],\n      [se.lng, nw.lat, ceil],\n    ];\n  }\n\n  static getSpaceById(id: string, zoom?: number) {\n    return new Space(id, zoom);\n  }\n\n  static getSpaceByLocation(loc: LngLatWithAltitude, zoom?: number) {\n    return new Space(loc, zoom);\n  }\n\n  static getSpaceByZFXY(zfxyStr: string) {\n    return new Space(zfxyStr);\n  }\n\n  /** Calculates the smallest spatial ID to fully contain the polygon. Currently only supports 2D polygons. */\n  static boundingSpaceForGeometry(geom: Geometry, minZoom?: number): Space {\n    minZoom = minZoom || 25;\n    const bbox = turfBBox(geom);\n    const largestTile = bboxToTile(bbox, minZoom);\n    const [ x, y, z ] = largestTile;\n    return new Space({x, y, z, f: 0});\n  }\n\n  /** Calculate an array of spaces that make up the polygon. Currently only supports 2D polygons. */\n  static spacesForGeometry(geom: Geometry, zoom: number): Space[] {\n    const z = zoom;\n\n    if (z === 0) {\n      // not recommended.\n      return [new Space('0/0/0/0')];\n    }\n\n    if (geom.type === 'GeometryCollection') {\n      throw new Error('GeometryCollection not supported');\n    }\n\n    // this can be optimized a lot!\n    const bbox = turfBBox(geom),\n          min = pointToTile(bbox[0], bbox[1], 32),\n          max = pointToTile(bbox[2], bbox[3], 32),\n          minX = (Math.min(min[0], max[0])) >>> (32 - z),\n          minY = (Math.min(min[1], max[1])) >>> (32 - z),\n          maxX = (Math.max(max[0], min[0]) >>> (32 - z)) + 1,\n          maxY = (Math.max(max[1], min[1]) >>> (32 - z)) + 1,\n          spaces: Space[] = [];\n\n    // scanline polygon fill algorithm\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        const space = new Space({x, y, z, f: 0});\n        if (turfBooleanIntersects(geom, space.toGeoJSON())) {\n          spaces.push(space);\n        }\n      }\n    }\n    return spaces;\n  }\n\n  private _regenerateAttributesFromZFXY() {\n    this.alt = getFloor(this.zfxy);\n    this.center = getCenterLngLatAlt(this.zfxy);\n    this.zoom = this.zfxy.z;\n    this.id = this.tilehash = generateTilehash(this.zfxy);\n    this.zfxyStr = `/${this.zfxy.z}/${this.zfxy.f}/${this.zfxy.x}/${this.zfxy.y}`;\n    this.hilbertIndex = generateHilbertIndex(this.zfxy);\n    this.hilbertTilehash = generateHilbertTilehash(this.hilbertIndex, this.zfxy.z);\n  }\n}\n"],"names":["featureCollection","coordEach","featureEach","geomEach","flattenEach","bbox","intersects","js","helpers","require$$0","require$$1","require$$2","require$$3","geojsonRbushModule","geojsonRbush_1","rbush","polygonToLine","turfBooleanIntersects","turfBBox"],"mappings":"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"}