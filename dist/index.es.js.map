{"version":3,"file":"index.es.js","sources":["../src/zfxy.ts","../src/zfxy_tilehash.ts","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/@turf/bbox/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../node_modules/@turf/line-segment/dist/es/index.js","../node_modules/quickselect/index.js","../node_modules/rbush/index.js","../node_modules/@turf/helpers/dist/js/index.js","../node_modules/@turf/meta/dist/js/index.js","../node_modules/@turf/bbox/dist/js/index.js","../node_modules/geojson-rbush/index.js","../node_modules/@turf/line-intersect/dist/es/index.js","../node_modules/@turf/polygon-to-line/dist/es/index.js","../node_modules/@turf/boolean-disjoint/dist/es/index.js","../node_modules/@turf/boolean-intersects/dist/es/index.js","../src/tilebelt.ts","../src/hilbert.ts","../src/hilbert_tilehash.ts","../src/index.ts"],"sourcesContent":["import { LngLat, LngLatWithAltitude } from \"./types\";\n\nexport type ZFXYTile = { z: number, f: number, x: number, y: number };\n\nexport function isZFXYTile(tile: any): tile is ZFXYTile {\n  return ('z' in tile && 'f' in tile && 'x' in tile && 'y' in tile);\n}\n\nexport const ZFXY_1M_ZOOM_BASE = 25 as const;\nexport const ZFXY_ROOT_TILE: ZFXYTile = { f: 0, x: 0, y: 0, z: 0 };\n\nconst rad2deg = 180 / Math.PI;\n\nexport function getParent(tile: ZFXYTile, steps: number = 1): ZFXYTile {\n  const { f,x,y,z } = tile;\n  if (steps <= 0) {\n    throw new Error('steps must be greater than 0');\n  }\n  if (steps > z) {\n    throw new Error(`Getting parent tile of ${tile}, ${steps} steps is not possible because it would go beyond the root tile (z=0)`);\n  }\n  return {\n    f: f >> steps,\n    x: x >> steps,\n    y: y >> steps,\n    z: z -  steps,\n  };\n}\n\nexport function getChildren(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\n  const {f,x,y,z} = tile;\n  return [\n    {f: f * 2,     x: x * 2,     y: y * 2,     z: z+1}, // f +0, x +0, y +0\n    {f: f * 2,     x: x * 2 + 1, y: y * 2,     z: z+1}, // f +0, x +1, y +0\n    {f: f * 2,     x: x * 2,     y: y * 2 + 1, z: z+1}, // f +0, x +0, y +1\n    {f: f * 2,     x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +0, x +1, y +1\n    {f: f * 2 + 1, x: x * 2,     y: y * 2,     z: z+1}, // f +1, x +0, y +0\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2,     z: z+1}, // f +1, x +1, y +0\n    {f: f * 2 + 1, x: x * 2,     y: y * 2 + 1, z: z+1}, // f +1, x +0, y +1\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +1, x +1, y +1\n  ];\n}\n\nexport function getSurrounding(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\n  const {f,x,y,z} = tile;\n  return [\n    zfxyWraparound({f: f, x: x,     y: y,     z: z}), // f +0, x +0, y +0\n    zfxyWraparound({f: f, x: x + 1, y: y,     z: z}), // f +0, x +1, y +0\n    zfxyWraparound({f: f, x: x,     y: y + 1, z: z}), // f +0, x +0, y +1\n    zfxyWraparound({f: f, x: x + 1, y: y + 1, z: z}), // f +0, x +1, y +1\n    zfxyWraparound({f: f, x: x - 1, y: y,     z: z}), // f +0, x -1, y +0\n    zfxyWraparound({f: f, x: x,     y: y - 1, z: z}), // f +0, x +0, y -1\n    zfxyWraparound({f: f, x: x - 1, y: y - 1, z: z}), // f +0, x -1, y -1\n    zfxyWraparound({f: f, x: x + 1, y: y - 1, z: z}), // f +0, x +1, y -1\n    zfxyWraparound({f: f, x: x - 1, y: y + 1, z: z}), // f +0, x -1, y +1\n  ];\n}\n\nexport function parseZFXYString(str: string): ZFXYTile | undefined {\n  const match = str.match(/^\\/?(\\d+)\\/(?:(\\d+)\\/)?(\\d+)\\/(\\d+)$/);\n  if (!match) {\n    return undefined;\n  }\n  return {\n    z: parseInt(match[1], 10),\n    f: parseInt(match[2] || '0', 10),\n    x: parseInt(match[3], 10),\n    y: parseInt(match[4], 10),\n  };\n}\n\n/** Returns the lng,lat of the northwest corner of the provided tile */\nexport function getLngLat(tile: ZFXYTile): LngLat {\n  const n = Math.PI - 2 * Math.PI * tile.y / Math.pow(2, tile.z);\n  return {\n    lng: tile.x / Math.pow(2, tile.z) * 360 - 180,\n    lat: rad2deg * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))),\n  };\n}\n\nexport function getCenterLngLat(tile: ZFXYTile): LngLat {\n  const x = tile.x * 2 + 1,\n        y = tile.y * 2 + 1,\n        z = tile.z + 1;\n  return getLngLat({x, y, z, f: 0});\n}\n\nexport function getCenterLngLatAlt(tile: ZFXYTile): LngLatWithAltitude {\n  return {\n    ...getCenterLngLat(tile),\n    alt: getFloor(tile) + ((2**ZFXY_1M_ZOOM_BASE) / (2**(tile.z + 1))),\n  };\n}\n\nexport function getBBox(tile: ZFXYTile): [LngLat, LngLat] {\n  const nw = getLngLat(tile),\n        se = getLngLat({...tile, y: tile.y + 1, x: tile.x + 1});\n  return [ nw, se ];\n}\n\n/** Returns the floor of the voxel, in meters */\nexport function getFloor(tile: ZFXYTile): number {\n  return tile.f * (2**ZFXY_1M_ZOOM_BASE) / (2**tile.z)\n}\n\nexport interface CalculateZFXYInput {\n  lat: number\n  lng: number\n  alt?: number\n  zoom: number\n}\n\nexport function calculateZFXY(input: CalculateZFXYInput): ZFXYTile {\n  const meters = typeof input.alt !== 'undefined' ? input.alt : 0;\n  if (meters <= -(2**ZFXY_1M_ZOOM_BASE) || meters >= (2**ZFXY_1M_ZOOM_BASE)) {\n    // TODO: make altitude unlimited?\n    throw new Error(`ZFXY only supports altitude between -2^${ZFXY_1M_ZOOM_BASE} and +2^${ZFXY_1M_ZOOM_BASE}.`);\n  }\n  const f = Math.floor(((2 ** input.zoom) * meters) / (2 ** ZFXY_1M_ZOOM_BASE));\n\n  // Algorithm adapted from tilebelt.js\n  const d2r = Math.PI / 180;\n  const sin = Math.sin(input.lat * d2r);\n  const z2 = 2 ** input.zoom;\n  let x = z2 * (input.lng / 360 + 0.5);\n  const y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n  // Wrap Tile X\n  x = x % z2;\n  if (x < 0) x = x + z2;\n\n  return {\n    f: f,\n    x: Math.floor(x),\n    y: Math.floor(y),\n    z: input.zoom,\n  };\n}\n\n/**\n * Fix a tile that has out-of-bounds coordinates by:\n * for the x and y coordinates: wrapping the coordinates around.\n * for the f coordinate: limiting to maximum or minimum.\n */\nexport function zfxyWraparound(tile: ZFXYTile): ZFXYTile {\n  const {z, f, x, y} = tile;\n  return {\n    z,\n    f: Math.max(Math.min(f, (2**z)), -(2**z)),\n    x: (x < 0) ? x + 2**z : x % 2**z,\n    y: (y < 0) ? y + 2**z : y % 2**z,\n  }\n}\n","import { ZFXYTile, getChildren, getParent } from \"./zfxy\";\n\nexport function parseZFXYTilehash(th: string): ZFXYTile {\n  let negativeF = false;\n  if (th[0] === '-') {\n    negativeF = true;\n    th = th.substring(1);\n  }\n  let children = getChildren();\n  let lastChild: ZFXYTile;\n  for (const c of th) {\n    lastChild = {...children[parseInt(c, 10) - 1]};\n    children = getChildren(lastChild);\n  }\n  if (negativeF) {\n    lastChild.f = -lastChild.f;\n  }\n  return lastChild;\n}\n\nexport function generateTilehash(tile: ZFXYTile): string {\n  let {f,x,y,z} = tile;\n  const originalF = f;\n  let out = '';\n  while (z>0) {\n    const thisTile: ZFXYTile = { f: Math.abs(f), x: x, y: y, z: z };\n    const parent = getParent(thisTile);\n    const childrenOfParent = getChildren(parent);\n    const positionInParent = childrenOfParent.findIndex(\n      (child) => child.f === Math.abs(f) && child.x === x && child.y === y && child.z === z\n    );\n    out = (positionInParent + 1).toString() + out;\n    f = parent.f;\n    x = parent.x;\n    y = parent.y;\n    z = parent.z;\n  }\n  return (originalF < 0 ? '-' : '') + out;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = helpers.lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              helpers.lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return helpers.point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexports.coordAll = coordAll;\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.findPoint = findPoint;\nexports.findSegment = findSegment;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexports.default = bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","import booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Boolean-intersects returns (TRUE) two geometries intersect.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point);\n * //=true\n */\nexport default function booleanIntersects(feature1, feature2) {\n    var bool = false;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === true) {\n                return true;\n            }\n            bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n","import { BBox } from \"geojson\";\n\nconst d2r = Math.PI / 180,\n      r2d = 180 / Math.PI,\n      MAX_ZOOM = 28;\n\nexport function getBboxZoom(bbox: BBox) {\n  for (let z = 0; z < MAX_ZOOM; z++) {\n    const mask = 1 << (32 - (z + 1));\n    if (((bbox[0] & mask) !== (bbox[2] & mask)) ||\n        ((bbox[1] & mask) !== (bbox[3] & mask))) {\n      return z;\n    }\n  }\n\n  return MAX_ZOOM;\n}\n\n/**\n * Get the smallest tile to cover a bbox\n */\nexport function bboxToTile(bboxCoords: BBox, minZoom?: number): Array<number> {\n  const min = pointToTile(bboxCoords[0], bboxCoords[1], 32);\n  const max = pointToTile(bboxCoords[2], bboxCoords[3], 32);\n  const bbox: BBox = [min[0], min[1], max[0], max[1]];\n\n  const z = Math.min(getBboxZoom(bbox), typeof minZoom !== 'undefined' ? minZoom : MAX_ZOOM);\n  if (z === 0) return [0, 0, 0];\n  const x = bbox[0] >>> (32 - z);\n  const y = bbox[1] >>> (32 - z);\n  return [x, y, z];\n}\n\n/**\n * Get the tile for a point at a specified zoom level\n */\nexport function pointToTile(lon: number, lat: number, z: number) {\n  var tile = pointToTileFraction(lon, lat, z);\n  tile[0] = Math.floor(tile[0]);\n  tile[1] = Math.floor(tile[1]);\n  return tile;\n}\n\n/**\n * Get the precise fractional tile location for a point at a zoom level\n */\nfunction pointToTileFraction(lon: number, lat: number, z: number) {\n  var sin = Math.sin(lat * d2r),\n      z2 = Math.pow(2, z),\n      x = z2 * (lon / 360 + 0.5),\n      y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n  // Wrap Tile X\n  x = x % z2;\n  if (x < 0) x = x + z2;\n  return [x, y, z];\n}\n","// Function 1: Encode (x,y,z) to Hilbert curve index\nexport function encodeHilbert3D(x: number, y: number, z: number, bits: number): bigint {\n  let morton = encodeMorton3D(x, y, z);\n  return mortonToHilbertN(morton, bits);\n}\n\n// Function 2: Decode Hilbert curve index to (x,y,z)\nexport function decodeHilbert3D(index: bigint, bits: number): [number, number, number] {\n  const morton = hilbertToMortonN(index, bits);\n  return decodeMorton3D(morton);\n}\n\n// Helper functions: Encode/decode Morton curve using magic bits\n// This is a 3D Morton curve implementation, adapted from https://stackoverflow.com/questions/1024754/how-to-compute-a-3d-morton-number-interleave-the-bits-of-3-ints\nexport function encodeMorton3D(x: number, y: number, z: number): bigint {\n  let morton = 0n;\n  morton = splitBy3(x) | (splitBy3(y) << 1n) | (splitBy3(z) << 2n);\n  return morton;\n}\n\nexport function decodeMorton3D(morton: bigint): [number, number, number] {\n  let x = compactBy3(morton);\n  let y = compactBy3(morton >> 1n);\n  let z = compactBy3(morton >> 2n);\n  return [x, y, z];\n}\n\nfunction splitBy3(a: number): bigint {\n  let x = BigInt(a) & BigInt('0x3ffffffffff');\n  x = (x | x << 64n) & BigInt('0x3ff0000000000000000ffffffff');\n  x = (x | x << 32n) & BigInt('0x3ff00000000ffff00000000ffff');\n  x = (x | x << 16n) & BigInt('0x30000ff0000ff0000ff0000ff0000ff');\n  x = (x | x <<  8n) & BigInt('0x300f00f00f00f00f00f00f00f00f00f');\n  x = (x | x <<  4n) & BigInt('0x30c30c30c30c30c30c30c30c30c30c3');\n  x = (x | x <<  2n) & BigInt('0x9249249249249249249249249249249');\n  return x;\n}\n\nfunction compactBy3(a: bigint): number {\n  let x = a & BigInt('0x9249249249249249249249249249249');\n  x = (x | x >>  2n) & BigInt('0x30c30c30c30c30c30c30c30c30c30c3');\n  x = (x | x >>  4n) & BigInt('0x300f00f00f00f00f00f00f00f00f00f');\n  x = (x | x >>  8n) & BigInt('0x30000ff0000ff0000ff0000ff0000ff');\n  x = (x | x >> 16n) & BigInt('0x3ff00000000ffff00000000ffff');\n  x = (x | x >> 32n) & BigInt('0x3ff0000000000000000ffffffff');\n  x = (x | x >> 64n) & BigInt('0x3ffffffffff');\n  return Number(x);\n}\n\n// Helper functions: Translate morton/hilbert codes using a simple lookup table\n// This code has been adapted from http://threadlocalmutex.com/?p=149\nconst mortonToHilbertTable: number[] = [\n  48, 33, 27, 34, 47, 78, 28, 77,\n  66, 29, 51, 52, 65, 30, 72, 63,\n  76, 95, 75, 24, 53, 54, 82, 81,\n  18,  3, 17, 80, 61,  4, 62, 15,\n   0, 59, 71, 60, 49, 50, 86, 85,\n  84, 83,  5, 90, 79, 56,  6, 89,\n  32, 23,  1, 94, 11, 12,  2, 93,\n  42, 41, 13, 14, 35, 88, 36, 31,\n  92, 37, 87, 38, 91, 74,  8, 73,\n  46, 45,  9, 10,  7, 20, 64, 19,\n  70, 25, 39, 16, 69, 26, 44, 43,\n  22, 55, 21, 68, 57, 40, 58, 67,\n];\n\nconst hilbertToMortonTable: number[] = [\n  48, 33, 35, 26, 30, 79, 77, 44,\n  78, 68, 64, 50, 51, 25, 29, 63,\n  27, 87, 86, 74, 72, 52, 53, 89,\n  83, 18, 16,  1,  5, 60, 62, 15,\n   0, 52, 53, 57, 59, 87, 86, 66,\n  61, 95, 91, 81, 80,  2,  6, 76,\n  32,  2,  6, 12, 13, 95, 91, 17,\n  93, 41, 40, 36, 38, 10, 11, 31,\n  14, 79, 77, 92, 88, 33, 35, 82,\n  70, 10, 11, 23, 21, 41, 40,  4,\n  19, 25, 29, 47, 46, 68, 64, 34,\n  45, 60, 62, 71, 67, 18, 16, 49,\n];\n\nfunction transformCurve(inValue: bigint, bits: number, lookupTable: number[]): bigint {\n  let transform = 0;\n  let out = 0n;\n\n  for (let i = 3 * (bits - 1); i >= 0; i -= 3) {\n    transform = lookupTable[transform | Number((inValue >> BigInt(i)) & 7n)];\n    out = (out << 3n) | BigInt(transform & 7);\n    transform &= ~7;\n  }\n\n  return out;\n};\n\nfunction mortonToHilbertN(mortonIndex: bigint, bits: number): bigint {\n  return transformCurve(mortonIndex, bits, mortonToHilbertTable);\n}\nfunction hilbertToMortonN(hilbertIndex: bigint, bits: number): bigint {\n  return transformCurve(hilbertIndex, bits, hilbertToMortonTable);\n}\n","// Functions to encode/decode 3D xyz coordinates to/from a Hilbert distance\n// Uses Skilling's algorithm because it was the easiest to adapt to 3D coordinates\n// (it's actually able to handle any number of dimensions, but we only need 3 right now)\n\nimport { ZFXYTile } from \"./zfxy\";\nimport { encodeHilbert3D, decodeHilbert3D } from \"./hilbert\";\n\nexport function generateHilbertIndex(tile: ZFXYTile): bigint {\n  // normalize the f attribute to be positive\n  // this allows negative f values to be encoded in the hilbert index\n  const f = tile.z > 0 ? tile.f + (2 ** (tile.z - 1)) : 0;\n  return encodeHilbert3D(tile.x, tile.y, f, tile.z);\n}\n\nexport function parseHilbertIndex(hilbertDistance: bigint, z: number): ZFXYTile {\n  if (z === 0) { return { z: 0, f: 0, x: 0, y: 0 }; }\n\n  const [x, y, originalF] = decodeHilbert3D(hilbertDistance, z);\n  // denormalize the f attribute\n  const f = originalF - (2 ** (z - 1));\n  return { f, x, y, z };\n}\n\nexport function generateHilbertTilehash(hilbertIndex: bigint, order: number): string {\n  // radix 8 compresses 3 bits into 1 character (0-7)\n  // we want 1-8, so we add 1 to each digit of the string\n  return 'H' + hilbertIndex.toString(8).padStart(order, '0').split('').map((c) => (parseInt(c) + 1).toString()).join('');\n}\n\nexport function parseHilbertTilehash(th: string): undefined | ZFXYTile {\n  if (th[0] !== 'H') {\n    return undefined;\n  }\n  // need to subtract 1 from each digit to convert back to radix 8\n  const thDigits = th.substring(1).split('').map((c) => (parseInt(c) - 1).toString()).join('');\n  const hilbertDistance = BigInt(\"0o\" + thDigits); // thDigits is in radix 8, so we can parse it as an octal\n  return parseHilbertIndex(hilbertDistance, thDigits.length);\n}\n","import { LngLatWithAltitude } from \"./types\";\nimport { calculateZFXY, getBBox, getChildren, getFloor, getParent, isZFXYTile, parseZFXYString, ZFXYTile, zfxyWraparound, getSurrounding, getCenterLngLatAlt } from \"./zfxy\";\nimport { generateTilehash, parseZFXYTilehash } from \"./zfxy_tilehash\";\nimport turfBBox from '@turf/bbox';\nimport turfBooleanIntersects from '@turf/boolean-intersects';\nimport type { Geometry, Polygon } from \"geojson\";\nimport { bboxToTile, pointToTile } from \"./tilebelt\";\nimport { generateHilbertIndex, generateHilbertTilehash, parseHilbertTilehash } from \"./hilbert_tilehash\";\n\nconst DEFAULT_ZOOM = 25 as const;\n\nexport class Space {\n  center: LngLatWithAltitude\n  alt: number\n  zoom: number\n\n  zfxy: ZFXYTile\n\n  id: string\n  zfxyStr: string\n  tilehash: string\n  hilbertIndex: bigint\n  hilbertTilehash: string\n\n  /**\n   * Create a new Space\n   *\n   * @param input A LngLatWithAltitude or string containing either a ZFXY or tilehash-encoded ZFXY.\n   * @param zoom Optional. Defaults to 25 when `input` is LngLatWithAltitude. Ignored when ZXFY or tilehash is provided.\n   */\n  constructor(input: LngLatWithAltitude | ZFXYTile | string, zoom?: number) {\n    if (typeof input === 'string') {\n      // parse string\n      let zfxy = parseZFXYString(input) || parseHilbertTilehash(input) || parseZFXYTilehash(input);\n      if (zfxy) {\n        this.zfxy = zfxy;\n        this._regenerateAttributesFromZFXY();\n      } else {\n        throw new Error(`parse ZFXY failed with input: ${input}`);\n      }\n      return;\n    } else if (isZFXYTile(input)) {\n      this.zfxy = input;\n      this._regenerateAttributesFromZFXY();\n      return;\n    } else {\n      this.zfxy = calculateZFXY({\n        ...input,\n        zoom: (typeof zoom !== 'undefined') ? zoom : DEFAULT_ZOOM,\n      });\n    }\n\n    this._regenerateAttributesFromZFXY();\n  }\n\n  /* - PUBLIC API - */\n\n  up(by: number = 1) {\n    return this.move({f: by});\n  }\n\n  down(by: number = 1) {\n    return this.move({f: -by});\n  }\n\n  north(by: number = 1) {\n    return this.move({y: by});\n  }\n\n  south(by: number = 1) {\n    return this.move({y: -by});\n  }\n\n  east(by: number = 1) {\n    return this.move({x: by});\n  }\n\n  west(by: number = 1) {\n    return this.move({x: -by});\n  }\n\n  move(by: Partial<Omit<ZFXYTile, 'z'>>) {\n    const newSpace = new Space(this.zfxy);\n    newSpace.zfxy = zfxyWraparound({\n      z: newSpace.zfxy.z,\n      f: newSpace.zfxy.f + (by.f || 0),\n      x: newSpace.zfxy.x + (by.x || 0),\n      y: newSpace.zfxy.y + (by.y || 0),\n    });\n    newSpace._regenerateAttributesFromZFXY();\n    return newSpace;\n  }\n\n  parent(atZoom?: number) {\n    const steps = (typeof atZoom === 'undefined') ? 1 : this.zfxy.z - atZoom;\n    return new Space(getParent(this.zfxy, steps));\n  }\n\n  children() {\n    return getChildren(this.zfxy).map((tile) => new Space(tile));\n  }\n\n  /** Return an array of Space objects at the same zoom level that surround this Space\n   * object. This method does not return the Space object itself, so the array will\n   * contain 26 Space objects.\n   */\n  surroundings(): Space[] {\n    return [\n      ...(\n        getSurrounding(this.zfxy)\n        .filter(({z,f,x,y}) => `/${z}/${f}/${x}/${y}` !== this.zfxyStr)\n        .map((tile) => new Space(tile))\n      ),\n      ...(\n        getSurrounding(this.up().zfxy)\n        .map((tile) => new Space(tile))\n      ),\n      ...(\n        getSurrounding(this.down().zfxy)\n        .map((tile) => new Space(tile))\n      ),\n    ];\n  }\n\n  /** Returns true if a point lies within this Space. If the position's altitude is not\n   * specified, it is ignored from the calculation.\n   */\n  contains(position: LngLatWithAltitude) {\n    const geom = this.toGeoJSON();\n    const point = {\n      type: 'Point',\n      coordinates: [position.lng, position.lat],\n    };\n    const floor = this.alt;\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\n    return (\n      turfBooleanIntersects(geom, point) &&\n      (typeof position.alt !== 'undefined' === true ?\n        position.alt >= floor && position.alt < ceil\n        :\n        true\n      )\n    );\n  }\n\n  /** Calculates the polygon of this Space and returns a 2D GeoJSON Polygon. */\n  toGeoJSON(): Polygon {\n    const [nw, se] = getBBox(this.zfxy);\n    return {\n      type: 'Polygon',\n      coordinates: [\n        [\n          [nw.lng, nw.lat],\n          [nw.lng, se.lat],\n          [se.lng, se.lat],\n          [se.lng, nw.lat],\n          [nw.lng, nw.lat],\n        ],\n      ],\n    };\n  }\n\n  /** Calculates the 3D polygon of this Space and returns the vertices of that polygon. */\n  vertices3d(): [number, number, number][] {\n    const [nw, se] = getBBox(this.zfxy);\n    const floor = getFloor(this.zfxy);\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\n    return [\n      [nw.lng, nw.lat, floor],\n      [nw.lng, se.lat, floor],\n      [se.lng, se.lat, floor],\n      [se.lng, nw.lat, floor],\n      [nw.lng, nw.lat, ceil],\n      [nw.lng, se.lat, ceil],\n      [se.lng, se.lat, ceil],\n      [se.lng, nw.lat, ceil],\n    ];\n  }\n\n  static getSpaceById(id: string, zoom?: number) {\n    return new Space(id, zoom);\n  }\n\n  static getSpaceByLocation(loc: LngLatWithAltitude, zoom?: number) {\n    return new Space(loc, zoom);\n  }\n\n  static getSpaceByZFXY(zfxyStr: string) {\n    return new Space(zfxyStr);\n  }\n\n  /** Calculates the smallest spatial ID to fully contain the polygon. Currently only supports 2D polygons. */\n  static boundingSpaceForGeometry(geom: Geometry, minZoom?: number): Space {\n    minZoom = minZoom || 25;\n    const bbox = turfBBox(geom);\n    const largestTile = bboxToTile(bbox, minZoom);\n    const [ x, y, z ] = largestTile;\n    return new Space({x, y, z, f: 0});\n  }\n\n  /** Calculate an array of spaces that make up the polygon. Currently only supports 2D polygons. */\n  static spacesForGeometry(geom: Geometry, zoom: number): Space[] {\n    const z = zoom;\n\n    if (z === 0) {\n      // not recommended.\n      return [new Space('0/0/0/0')];\n    }\n\n    if (geom.type === 'GeometryCollection') {\n      throw new Error('GeometryCollection not supported');\n    }\n\n    // this can be optimized a lot!\n    const bbox = turfBBox(geom),\n          min = pointToTile(bbox[0], bbox[1], 32),\n          max = pointToTile(bbox[2], bbox[3], 32),\n          minX = (Math.min(min[0], max[0])) >>> (32 - z),\n          minY = (Math.min(min[1], max[1])) >>> (32 - z),\n          maxX = (Math.max(max[0], min[0]) >>> (32 - z)) + 1,\n          maxY = (Math.max(max[1], min[1]) >>> (32 - z)) + 1,\n          spaces: Space[] = [];\n\n    // scanline polygon fill algorithm\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        const space = new Space({x, y, z, f: 0});\n        if (turfBooleanIntersects(geom, space.toGeoJSON())) {\n          spaces.push(space);\n        }\n      }\n    }\n    return spaces;\n  }\n\n  private _regenerateAttributesFromZFXY() {\n    this.alt = getFloor(this.zfxy);\n    this.center = getCenterLngLatAlt(this.zfxy);\n    this.zoom = this.zfxy.z;\n    this.id = this.tilehash = generateTilehash(this.zfxy);\n    this.zfxyStr = `/${this.zfxy.z}/${this.zfxy.f}/${this.zfxy.x}/${this.zfxy.y}`;\n    this.hilbertIndex = generateHilbertIndex(this.zfxy);\n    this.hilbertTilehash = generateHilbertTilehash(this.hilbertIndex, this.zfxy.z);\n  }\n}\n"],"names":["featureCollection","coordEach","featureEach","geomEach","flattenEach","bbox","intersects","js","helpers","require$$0","require$$1","require$$2","require$$3","geojsonRbushModule","geojsonRbush_1","rbush","polygonToLine","turfBooleanIntersects","turfBBox"],"mappings":"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"}